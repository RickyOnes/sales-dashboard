<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HLS视频解密修复工具</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1080px;
            margin: 5px auto;
            background: rgba(30, 30, 45, 0.85);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        header {
            background: rgba(15, 15, 25, 0.9);
            padding: 15px 30px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.2rem;
            background: linear-gradient(to right, #00c6ff, #0072ff);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #a0a0c0;
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .content {
            padding: 10px;
        }
        
        .card {
            background: rgba(40, 40, 60, 0.7);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .url-input {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 15px;
            font-size: 1.1rem;
            border: 2px solid #444;
            border-radius: 8px;
            background: rgba(20, 20, 30, 0.8);
            color: white;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #00c6ff;
        }
        
        button {
            background: linear-gradient(to right, #00c6ff, #0072ff);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0, 114, 255, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 20px rgba(0, 114, 255, 0.6);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button:disabled {
            background: #666;
            transform: none;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .progress-container {
            margin-top: 25px;
            height: 25px;
            background: rgba(50, 50, 70, 0.6);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00c9ff, #92fe9d);
            width: 0%;
            transition: width 0.5s;
            position: relative;
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: 600;
            z-index: 2;
            text-shadow: 0 0 2px rgba(0, 0, 0, 0.7);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 25px;
            background: rgba(40, 40, 60, 0.6);
            border-radius: 12px;
            padding: 20px;
        }
        
        .stat-card {
            background: rgba(25, 25, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(to right, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #a0a0c0;
            font-size: 0.9rem;
        }
        
        .decrypt-info {
            margin-top: 20px;
            background: rgba(20, 60, 90, 0.4);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #00c6ff;
        }
        
        .decrypt-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            color: #00c6ff;
        }
        
        .key-value {
            font-family: monospace;
            word-break: break-all;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
            margin-top: 5px;
        }
        
        footer {
            text-align: center;
            padding: 25px;
            color: #a0a0c0;
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hidden {
            display: none;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        .working {
            animation: pulse 1.5s infinite;
        }
        
        /* 视频播放器样式 */
        .video-container {
            background: rgba(40, 40, 60, 0.7);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .video-container h2 {
            margin-bottom: 15px;
        }
        
        #video-player {
            width: 100%;
            height: auto;
            background: black;
            border-radius: 8px;
            display: block;
        }
        
        .video-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .video-controls button {
            padding: 10px 15px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>HLS视频解密修复工具</h1>
            <p class="subtitle">解密AES-128加密的HLS视频流</p>
        </header>
        
        <div class="content">
            <div class="card">
                <h2>M3U8文件地址</h2>
                <div class="url-input">
                    <input type="text" id="m3u8-url" value="https://cnmgg.cjswds.com/720p/m3u8/2025/08/01/1951163754699816962/index.m3u8" placeholder="输入M3U8文件地址">
                    <button id="download-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" y1="15" x2="12" y2="3"></line>
                        </svg>
                        下载并解密视频
                    </button>
                </div>
            </div>
            
            <!-- 视频播放窗口 -->
            <div class="video-container">
                <h2>视频播放器</h2>
                <video id="video-player" controls></video>
                <div class="video-controls">
                    <button id="load-video-btn">加载视频</button>
                    <button id="play-video-btn" disabled>播放</button>
                    <button id="pause-video-btn" disabled>暂停</button>
                </div>
            </div>
            
            <div class="decrypt-info">
                <div class="decrypt-header">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#00c6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                    </svg>
                    <h3>视频加密信息</h3>
                </div>
                <p>检测到该视频使用<strong>AES-128加密</strong>，需要解密才能正常播放：</p>
                <p>解密密钥URI: <span class="key-value" id="key-uri">enc.key</span></p>
                <p>初始化向量(IV): <span class="key-value" id="key-iv">0x761db54c011650ed76b40beb26583870</span></p>
            </div>
            
            <div class="progress-container">
                <div class="progress-fill" id="progress-fill"></div>
                <div class="progress-text" id="progress-text">准备就绪</div>
            </div>
            
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="ts-count">0</div>
                    <div class="stat-label">TS分片数</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ts-processed">0</div>
                    <div class="stat-label">已处理</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ts-size">0 MB</div>
                    <div class="stat-label">文件大小</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="ts-errors">0</div>
                    <div class="stat-label">修复问题</div>
                </div>
            </div>
            
            <div class="card hidden" id="final-step">
                <h2>解密成功</h2>
                <p>视频已成功解密为TS格式，点击下方按钮下载：</p>
                <button id="download-final">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                    下载解密后的视频
                </button>
            </div>
        </div>
        
        <footer>
            <p>高级视频解密与修复引擎 &copy; 2025 | 专为AES-128加密HLS视频设计</p>
        </footer>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const m3u8UrlInput = document.getElementById('m3u8-url');
            const downloadBtn = document.getElementById('download-btn');
            const downloadFinalBtn = document.getElementById('download-final');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const tsCountElement = document.getElementById('ts-count');
            const tsProcessedElement = document.getElementById('ts-processed');
            const tsSizeElement = document.getElementById('ts-size');
            const tsErrorsElement = document.getElementById('ts-errors');
            const finalStepCard = document.getElementById('final-step');
            const keyUriElement = document.getElementById('key-uri');
            const keyIvElement = document.getElementById('key-iv');
            
            // 视频播放器相关元素
            const videoPlayer = document.getElementById('video-player');
            const loadVideoBtn = document.getElementById('load-video-btn');
            const playVideoBtn = document.getElementById('play-video-btn');
            const pauseVideoBtn = document.getElementById('pause-video-btn');
            
            let videoBlob = null;
            let hls = null;
            
            downloadBtn.addEventListener('click', startRepairProcess);
            downloadFinalBtn.addEventListener('click', () => {
                if (videoBlob) {
                    // 生成带时间戳的文件名
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    const hours = String(now.getHours()).padStart(2, '0');
                    const minutes = String(now.getMinutes()).padStart(2, '0');
                    const filename = `av${year}${month}${day}${hours}${minutes}.ts`;
                    triggerDownload(videoBlob, filename);
                }
            });
            
            // 视频播放器事件监听
            loadVideoBtn.addEventListener('click', loadVideo);
            playVideoBtn.addEventListener('click', () => videoPlayer.play());
            pauseVideoBtn.addEventListener('click', () => videoPlayer.pause());
            
            function loadVideo() {
                const m3u8Url = m3u8UrlInput.value.trim();
                if (!m3u8Url) {
                    alert('请输入M3U8文件地址');
                    return;
                }
                
                // 如果已经有一个HLS实例，先销毁它
                if (hls) {
                    hls.destroy();
                }
                
                // 检查HLS.js是否支持
                if (Hls.isSupported()) {
                    hls = new Hls();
                    hls.loadSource(m3u8Url);
                    hls.attachMedia(videoPlayer);
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, () => {
                        playVideoBtn.disabled = false;
                        pauseVideoBtn.disabled = false;
                        updateStatus("视频加载完成");
                    });
                    
                    hls.on(Hls.Events.ERROR, (event, data) => {
                        console.error('HLS Error:', data);
                        updateStatus(`播放错误: ${data.type} - ${data.details}`);
                    });
                } 
                // 检查原生HLS支持（Safari）
                else if (videoPlayer.canPlayType('application/vnd.apple.mpegurl')) {
                    videoPlayer.src = m3u8Url;
                    videoPlayer.addEventListener('loadedmetadata', () => {
                        playVideoBtn.disabled = false;
                        pauseVideoBtn.disabled = false;
                        updateStatus("视频加载完成");
                    });
                } 
                else {
                    updateStatus("您的浏览器不支持HLS播放");
                }
            }
            
            async function startRepairProcess() {
                // 重置UI
                resetUI();
                downloadBtn.disabled = true;
                downloadBtn.innerHTML = '<span class="working">处理中</span>';
                finalStepCard.classList.add('hidden');
                
                try {
                    const M3U8_URL = m3u8UrlInput.value.trim();
                    const BASE_URL = M3U8_URL.substring(0, M3U8_URL.lastIndexOf('/') + 1);
                    
                    updateStatus("正在获取视频信息...");
                    
                    // 1. 获取m3u8文件内容
                    const m3u8Response = await fetch(M3U8_URL);
                    const m3u8Text = await m3u8Response.text();
                    
                    // 2. 解析出所有.ts文件
                    const tsFiles = m3u8Text.split('\n')
                        .filter(line => line.endsWith('.ts') && !line.startsWith('#'));
                    
                    // 更新统计信息
                    tsCountElement.textContent = tsFiles.length;
                    
                    updateStatus(`解析到 ${tsFiles.length} 个视频分片`);
                    
                    // 3. 获取加密信息
                    const keyInfo = extractKeyInfo(m3u8Text);
                    
                    // 4. 智能处理密钥URI（相对路径或绝对路径）
                    const keyUrl = resolveKeyUrl(keyInfo.uri, BASE_URL);
                    updateStatus(`密钥URI解析: ${keyInfo.uri} → ${keyUrl}`);
                    
                    // 更新页面上显示的密钥URI和IV
                    keyUriElement.textContent = keyUrl;
                    keyIvElement.textContent = keyInfo.iv || '未指定（将使用默认值）';
                    
                    // 5. 下载密钥
                    updateStatus("下载解密密钥...");
                    const key = await downloadKey(keyUrl);
                    
                    // 6. 处理所有分片（下载、解密）
                    updateStatus("处理视频分片...");
                    videoBlob = await processAllTSFiles(tsFiles, BASE_URL, key, keyInfo.iv);
                    
                    // 7. 显示下载按钮
                    finalStepCard.classList.remove('hidden');
                    updateStatus("视频解密完成!");
                    tsSizeElement.textContent = (videoBlob.size / (1024 * 1024)).toFixed(1) + " MB";
                    
                } catch (error) {
                    console.error("视频处理失败:", error);
                    updateStatus(`处理失败: ${error.message}`);
                } finally {
                    downloadBtn.disabled = false;
                    downloadBtn.textContent = '下载并解密视频';
                    downloadBtn.classList.remove('working');
                }
            }
            
            function extractKeyInfo(m3u8Text) {
                const keyLine = m3u8Text.split('\n')
                    .find(line => line.startsWith('#EXT-X-KEY'));
                
                if (!keyLine) throw new Error('未找到加密密钥信息');
                
                // 使用正则表达式更安全地提取参数
                const methodMatch = keyLine.match(/METHOD=([^,]*)/);
                const uriMatch = keyLine.match(/URI="([^"]*)"/) || keyLine.match(/URI=([^,]*)/);
                const ivMatch = keyLine.match(/IV=([^,]*)/);
                
                if (!methodMatch) throw new Error('未找到加密方法参数');
                if (!uriMatch) throw new Error('未找到密钥URI参数');
                
                const method = methodMatch[1].replace(/"/g, '');
                const uri = uriMatch[1].replace(/"/g, '');
                const iv = ivMatch ? ivMatch[1].replace(/"/g, '') : null;
                
                return { method, uri, iv };
            }
            
            // 智能解析密钥URL（处理相对路径和绝对路径）
            function resolveKeyUrl(uri, baseUrl) {
                // 检查是否为绝对路径（包含协议）
                if (uri.startsWith('http://') || uri.startsWith('https://')) {
                    console.log("检测到绝对路径密钥URI:", uri);
                    return uri;
                } else {
                    // 相对路径，基于M3U8文件的基URL
                    console.log("检测到相对路径密钥URI:", uri);
                    return baseUrl + uri;
                }
            }
            
            // 修复后的密钥下载函数
            async function downloadKey(keyUrl) {
                const response = await fetch(keyUrl);
                
                // 获取响应体作为数组缓冲区
                const buffer = await response.arrayBuffer();
                const keyBytes = new Uint8Array(buffer);
                
                // 尝试将字节数组转换为字符串，看是否是可读的密钥
                const keyText = new TextDecoder().decode(keyBytes);
                
                // 如果是16字符字符串直接使用
                if (keyText.length === 16) {
                    return keyBytes;
                }
                
                // 如果是Base64编码
                if (keyText.length === 24) {
                    const binaryKey = atob(keyText);
                    return new TextEncoder().encode(binaryKey);
                }
                
                // 其他情况直接返回字节数组
                return keyBytes;
            }
            
            // 并行处理所有TS文件
            async function processAllTSFiles(tsFiles, baseUrl, key, ivHex) {
                const total = tsFiles.length;
                let issuesFixed = 0;
                let totalSize = 0;
                
                // 存储处理好的分片（使用更紧凑的结构）
                const decryptedChunks = [];
                
                // 设置并发限制
                const CONCURRENT_LIMIT = 10;
                let processed = 0;
                
                updateStatus(`开始并行处理 ${total} 个分片，最大并发数: ${CONCURRENT_LIMIT}`);
                
                // 创建处理任务队列
                const processQueue = async () => {
                    while (true) {
                        const index = processed++;
                        if (index >= total) break;
                        
                        const tsFile = tsFiles[index];
                        const url = baseUrl + tsFile;
                        
                        try {
                            updateStatus(`处理分片: ${index + 1}/${total}`);
                            const response = await fetch(url, { 
                                mode: 'cors',
                                credentials: 'omit'
                            });
                            
                            if (!response.ok) {
                                throw new Error(`下载失败: ${response.status} ${url}`);
                            }
                            
                            const encryptedData = await response.arrayBuffer();
                            const decryptedData = await decryptTSChunk(
                                new Uint8Array(encryptedData), 
                                new Uint8Array(key), 
                                ivHex
                            );
                            
                            // 验证解密数据
                            if (decryptedData[0] !== 0x47) {
                                console.warn('解密数据不以TS同步字节开头 (0x47)，实际值:', decryptedData[0].toString(16));
                                issuesFixed++;
                                tsErrorsElement.textContent = issuesFixed;
                            }
                            
                            // 存储分片
                            decryptedChunks[index] = decryptedData;
                            totalSize += decryptedData.length;
                            
                            // 更新进度
                            const progress = Math.round(((index + 1) / total) * 100);
                            updateProgress(progress);
                            tsProcessedElement.textContent = index + 1;
                            tsSizeElement.textContent = (totalSize / (1024 * 1024)).toFixed(1) + " MB";
                        } catch (error) {
                            console.error(`处理分片 ${tsFile} 时出错:`, error);
                            throw error;
                        }
                    }
                };
                
                // 创建并发任务
                const workers = Array(Math.min(CONCURRENT_LIMIT, total))
                    .fill()
                    .map(processQueue);
                
                // 等待所有任务完成
                await Promise.all(workers);
                
                // 合并分片并立即清理内存
                const blob = new Blob(decryptedChunks, { type: 'video/MP2T' });
                
                // 清理内存
                decryptedChunks.length = 0;
                
                return blob;
            }
            
            // 修复后的解密函数
            async function decryptTSChunk(encryptedData, key, ivHex) {
                // 转换IV
                let ivBytes;
                if (ivHex) {
                    const ivStr = ivHex.startsWith('0x') ? ivHex.substring(2) : ivHex;
                    ivBytes = hexToBytes(ivStr);
                } else {
                    // 如果没有提供IV，使用全0的IV
                    ivBytes = new Uint8Array(16);
                }
                
                // 使用CryptoJS解密
                const encryptedWordArray = CryptoJS.lib.WordArray.create(
                    encryptedData.buffer,
                    encryptedData.byteLength
                );
                
                const keyWordArray = CryptoJS.lib.WordArray.create(
                    key.buffer,
                    key.byteLength
                );
                
                const ivWordArray = CryptoJS.lib.WordArray.create(
                    ivBytes.buffer,
                    ivBytes.byteLength
                );
                
                const decrypted = CryptoJS.AES.decrypt(
                    { ciphertext: encryptedWordArray },
                    keyWordArray,
                    { 
                        iv: ivWordArray,
                        mode: CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.NoPadding
                    }
                );
                
                // 正确转换回Uint8Array
                const decryptedBytes = new Uint8Array(decrypted.sigBytes);
                for (let i = 0; i < decrypted.sigBytes; i++) {
                    const byte = decrypted.words[Math.floor(i / 4)] >>> (24 - (i % 4) * 8) & 0xff;
                    decryptedBytes[i] = byte;
                }
                
                return decryptedBytes;
            }
            
            // 修复后的hexToBytes函数
            function hexToBytes(hex) {
                // 确保长度是偶数
                if (hex.length % 2 !== 0) {
                    hex = '0' + hex;
                }
                
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes;
            }
                        
            function triggerDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
            }
            
            function updateStatus(message) {
                progressText.textContent = message;
            }
            
            function updateProgress(percent) {
                const progress = Math.min(100, Math.max(0, percent));
                progressFill.style.width = `${progress}%`;
            }
            
            function resetUI() {
                progressFill.style.width = '0%';
                progressText.textContent = '准备就绪';
                tsCountElement.textContent = '0';
                tsProcessedElement.textContent = '0';
                tsSizeElement.textContent = '0 MB';
                tsErrorsElement.textContent = '0';
                // 重置密钥信息显示为默认值
                keyUriElement.textContent = 'enc.key';
                keyIvElement.textContent = '0x761db54c011650ed76b40beb26583870';
                
                // 重置视频播放器按钮状态
                playVideoBtn.disabled = true;
                pauseVideoBtn.disabled = true;
            }
        });
    </script>
</body>
</html>